package main

/*标题：扑克牌的堆栈、队列操作
描述信息
我手中有一堆扑克牌， 但是观众不知道它的顺序。
第一步， 我从牌顶拿出一张牌， 放到桌子上。
第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。
第三步， 重复第一步的操作， 直到我手中所有的牌都放到了桌子上。
最后， 观众可以看到桌子上牌的顺序是：13\12\11\10\9\8\7\6\5\4\3\2\1 请问， 我刚开始拿在手里的牌的顺序是什么？
参考答案
解法一： 这道题候选人容易出现折半的思路， 其实考虑的复杂了。 本质是将一个队列和栈做了两个操作 1. 出队、入栈 2. 出队、入队（队尾）
因为是看得到结果， 看不到初始顺序， 那么这个操作就是一个逆操作。1. 出栈、入队 2. 出队（队尾）、入队（队首） 答案： 输入：1,2,3,4,5,6,7,8,9,10,11,12,13, 输出：1,12,2,8,3,11,4,9,5,13,6,10,7,
代码如下
int doTheWork(std::deque<int> * pQ, std::stack<int> * pS)
{
        if(NULL == pQ or NULL == pS)
                return -1;
        while(pS->size() > 0)
        {
                int val = pS->top();
                pS->pop();
                if (pQ->size() > 0)
                {
                        int tmp = pQ->back();
                        pQ->pop_back();
                        pQ->push_front(tmp);
                        pQ->push_front(val);
                }
                else
                {
                        pQ->push_front(val);
                }
        }
        return 0;
}
解法二： 对手上牌按照 a，b，c...进行编码，直接按顺序操作，输出结果和桌上实际结果对应，即为原手上牌的顺序。
评分标准
该题目最多得分 3 分，代码质量较高者可视情况给 3.5 分；1. 2.5 分及以下：2. 3.0 分：考虑使用队列和栈， 给 3 分， 代码基本正确；3. 3.5 分：代码质量较高，效率较高，可给 3.5 分*/

func fn(arr []int) []int{

}
